<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
<title>æ¯”ç‰¹å¸åŠ©è®°è¯ç”Ÿæˆ (å®Œæ•´ä¿®å¤ç‰ˆ)</title>

<!-- å®‰å…¨å¢å¼ºï¼šç§»é™¤å¤–éƒ¨CDNå­—ä½“ä¾èµ–ï¼Œä½¿ç”¨ç³»ç»Ÿå­—ä½“ -->
<style>
:root {
  --bg-primary: #F8F9FA;
  --bg-secondary: #FFFFFF;
  --bg-gradient-start: #F8F9FA;
  --bg-gradient-end: #E0F2F7;
  --text-primary: #111827;
  --text-secondary: #4B5563;
  --text-muted: #6B7280;
  --border-color: #E5E7EB;
  --border-light: #D1D5DB;
  --primary: #F7931A;
  --primary-gradient-start: #F7931A;
  --primary-gradient-end: #FFB84D;
  --primary-hover: #E68517;
  --secondary: #FFFFFF;
  --secondary-border: #E5E7EB;
  --secondary-text: #1F2937;
  --mnemonic-bg: #F3F4F6;
  --success: #0E9F6E;
  --radius: 0.75rem;
  --shadow-sm: 0 1px 3px rgba(15, 23, 42, 0.08), 0 1px 2px rgba(15, 23, 42, 0.04);
  --shadow-md: 0 10px 20px rgba(15, 23, 42, 0.1), 0 3px 6px rgba(15, 23, 42, 0.05);
}

[data-theme="dark"] {
  --bg-primary: #0A0F1E;
  --bg-secondary: #141C2F;
  --bg-gradient-start: #0A0F1E;
  --bg-gradient-end: #1F2A44;
  --text-primary: #F3F4F6;
  --text-secondary: #CBD5F5;
  --text-muted: #9CA3AF;
  --border-color: #2E3A56;
  --border-light: #3E4A6A;
  --secondary: #1F2A44;
  --secondary-border: #2E3A56;
  --secondary-text: #E5E7EB;
  --mnemonic-bg: #1B253D;
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html {
  overflow-x: hidden;
  -webkit-text-size-adjust: 100%;
  -webkit-tap-highlight-color: transparent;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  background: linear-gradient(to bottom, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  color: var(--text-primary);
  line-height: 1.6;
  opacity: 0;
  transform: translateY(20px);
  transition: opacity 0.4s ease, transform 0.4s ease;
}

body.loaded {
  opacity: 1;
  transform: translateY(0);
}

.theme-toggle {
  position: fixed;
  top: 1.5rem;
  right: 1.5rem;
  width: 48px;
  height: 48px;
  border-radius: 50%;
  background: linear-gradient(135deg, #4B5563 0%, #1F2937 100%);
  border: 1px solid rgba(15, 23, 42, 0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: var(--shadow-sm);
  color: #F9FAFB;
  cursor: pointer;
  transition: transform 0.25s ease, box-shadow 0.25s ease;
  z-index: 40;
}

[data-theme="dark"] .theme-toggle {
  background: linear-gradient(135deg, #F59E0B 0%, #F97316 100%);
  border-color: rgba(249, 115, 22, 0.6);
  color: #0F172A;
}

.theme-toggle:hover {
  transform: scale(1.06);
  box-shadow: 0 12px 25px rgba(15, 23, 42, 0.18);
}

.theme-toggle svg {
  width: 22px;
  height: 22px;
  stroke-width: 2.2;
}

header {
  width: 100%;
  max-width: 1100px;
  padding: 4rem 1.5rem 1.5rem;
  text-align: center;
}

header h1 {
  font-size: clamp(2rem, 4vw, 3rem);
  font-weight: 800;
  letter-spacing: -0.03em;
  margin-bottom: 0.75rem;
}

header p {
  color: var(--text-secondary);
  max-width: 660px;
  margin: 0 auto;
  font-size: 1.05rem;
}

.container {
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2.5rem;
  padding-bottom: 4rem;
}

.security-features {
  width: min(96%, 960px);
  border-radius: var(--radius);
  border: 1px solid rgba(79, 70, 229, 0.15);
  background: linear-gradient(145deg, rgba(79, 70, 229, 0.08), rgba(147, 197, 253, 0.12));
  box-shadow: var(--shadow-sm);
  padding: 1.5rem 1.75rem;
}

.security-features h3 {
  font-size: 1rem;
  font-weight: 600;
  color: var(--text-secondary);
  margin-bottom: 1rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.security-features-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
  gap: 0.75rem 1.5rem;
  font-size: 0.95rem;
  color: var(--text-muted);
}

main {
  width: min(96%, 960px);
  background: rgba(255, 255, 255, 0.9);
  border-radius: calc(var(--radius) * 1.1);
  border: 1px solid rgba(148, 163, 184, 0.25);
  box-shadow: var(--shadow-md);
  padding: clamp(1.75rem, 3vw, 2.5rem);
  backdrop-filter: blur(6px);
}

[data-theme="dark"] main {
  background: rgba(17, 25, 40, 0.82);
  border-color: rgba(148, 163, 184, 0.18);
}

.warning {
  display: flex;
  align-items: flex-start;
  gap: 1.25rem;
  background: linear-gradient(135deg, rgba(248, 113, 113, 0.18), rgba(239, 68, 68, 0.22));
  border: 1px solid rgba(248, 113, 113, 0.35);
  border-radius: calc(var(--radius) * 0.85);
  padding: 1.75rem;
  margin-bottom: 1.75rem;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2);
}

.warning-icon {
  font-size: 1.75rem;
}

.warning-content strong {
  display: block;
  font-size: 1.4rem;
  margin-bottom: 0.35rem;
}

.warning-text {
  color: var(--text-secondary);
  font-size: 1rem;
  line-height: 1.6;
}

.options {
  display: flex;
  flex-wrap: wrap;
  gap: 0.75rem;
  align-items: center;
  margin-bottom: 1.5rem;
}

.options label {
  font-weight: 600;
  color: var(--text-secondary);
  margin-right: 0.5rem;
}

.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 0.75rem 1.5rem;
  border-radius: 999px;
  border: none;
  background: linear-gradient(135deg, var(--primary-gradient-start), var(--primary-gradient-end));
  color: #FFFFFF;
  font-weight: 600;
  cursor: pointer;
  min-width: 140px;
  min-height: 46px;
  box-shadow: 0 12px 20px rgba(247, 147, 26, 0.25);
  position: relative;
  overflow: hidden;
  transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
}

.btn:hover {
  transform: translateY(-1px);
  background: linear-gradient(135deg, #F78308, #FFB347);
  box-shadow: 0 16px 26px rgba(247, 147, 26, 0.32);
}

.btn:active {
  transform: translateY(0);
}

.btn.btn-secondary {
  background: var(--secondary);
  color: var(--text-secondary);
  border: 1px solid var(--secondary-border);
  box-shadow: var(--shadow-sm);
}

.btn.btn-secondary:hover {
  background: rgba(249, 250, 251, 0.9);
}

.controls {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
  margin-bottom: 1.75rem;
}

.controls .btn {
  flex: 1 1 220px;
}

.mnemonic {
  display: flex;
  flex-wrap: wrap;
  gap: clamp(0.75rem, 2.5vw, 1.5rem);
  padding: clamp(1.25rem, 3vw, 2rem);
  background: var(--mnemonic-bg);
  border-radius: calc(var(--radius) * 0.9);
  min-height: 5rem;
  margin-bottom: 1.75rem;
  border: 1px dashed rgba(148, 163, 184, 0.4);
}

#mnemonic span {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 0.9rem 1.4rem;
  font-weight: 600;
  font-size: clamp(1.1rem, 2.4vw, 1.4rem);
  letter-spacing: 0.03em;
  text-transform: lowercase;
  color: #FFFFFF;
  background: linear-gradient(135deg, rgba(247, 147, 26, 0.85), rgba(255, 184, 77, 0.85));
  border-radius: 0.75rem;
  box-shadow: 0 12px 20px rgba(247, 147, 26, 0.28);
  min-width: 120px;
  text-align: center;
}

.address-section {
  display: none;
  flex-direction: column;
  gap: 0.75rem;
  padding: 1.5rem;
  border: 1px solid rgba(148, 163, 184, 0.4);
  border-radius: calc(var(--radius) * 0.9);
  background: rgba(255, 255, 255, 0.65);
}

[data-theme="dark"] .address-section {
  background: rgba(17, 25, 40, 0.6);
}

.address-section.active {
  display: flex;
}

.address-label {
  font-weight: 600;
  color: var(--text-secondary);
}

.address-container {
  display: flex;
  gap: 0.75rem;
  flex-wrap: wrap;
}

.address-input {
  flex: 1 1 240px;
  padding: 0.75rem 1rem;
  border-radius: 999px;
  border: 1px solid var(--border-color);
  background: rgba(255, 255, 255, 0.85);
  font-family: "SFMono-Regular", "Menlo", "Consolas", monospace;
  font-size: 0.95rem;
}

.btn-copy-address {
  min-width: 120px;
}

footer {
  width: 100%;
  text-align: center;
  color: var(--text-muted);
  font-size: 0.9rem;
  padding: 1.5rem 0 0;
}

@media (max-width: 768px) {
  header {
    padding-top: 3rem;
  }

  main {
    padding: 1.5rem;
  }

  .controls {
    flex-direction: column;
  }

  .controls .btn,
  .options .btn {
    width: 100%;
  }

  #mnemonic span {
    flex: 1 1 calc(50% - 0.75rem);
  }

  .address-container {
    flex-direction: column;
  }

  .btn-copy-address,
  .address-input {
    width: 100%;
  }
}

@media (max-width: 480px) {
  .theme-toggle {
    top: 1rem;
    right: 1rem;
    width: 42px;
    height: 42px;
  }

  header h1 {
    font-size: 2rem;
  }

  #mnemonic span {
    flex: 1 1 100%;
  }
}

.btn.loading {
  pointer-events: none;
  opacity: 0.8;
}

.ripple {
  position: absolute;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.4);
  transform: scale(0);
  animation: ripple-animation 0.6s ease-out;
  pointer-events: none;
}

@keyframes ripple-animation {
  to {
    transform: scale(4);
    opacity: 0;
  }
}

/* å®‰å…¨å¢å¼ºï¼šç§»é™¤å¤–éƒ¨CSSå¼•ç”¨ï¼Œç¡®ä¿å®Œå…¨ç¦»çº¿è¿è¡Œ */
</style>
</head>
<body>
<!-- ä¸»é¢˜åˆ‡æ¢æŒ‰é’® -->
<button class="theme-toggle" id="theme-toggle" aria-label="åˆ‡æ¢ä¸»é¢˜">
  <svg id="sun-icon" style="display: none;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
  </svg>
  <svg id="moon-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
  </svg>
</button>

<div class="container">
  <header>
    <h1>æ¯”ç‰¹å¸åŠ©è®°è¯ç”Ÿæˆ</h1>
    <p>å®Œå…¨ç¦»çº¿ Â· å¼ºçƒˆå»ºè®®æ–­ç½‘ä½¿ç”¨ Â· å®‰å…¨å¢å¼ºç‰ˆ</p>
  </header>

  <!-- å®‰å…¨ç‰¹æ€§å±•ç¤º -->
  <div class="security-features">
    <h3>ğŸ”’ å®‰å…¨ç‰¹æ€§</h3>
    <div class="security-features-grid">
      <div>âœ… å®Œå…¨ç¦»çº¿è¿è¡Œ</div>
      <div>âœ… é›¶å¤–éƒ¨ä¾èµ–</div>
      <div>âœ… éšç§æ¨¡å¼ï¼ˆæ— localStorageï¼‰</div>
      <div>âœ… å†…å­˜å®‰å…¨æ¸…ç†</div>
      <div>âœ… æ ‡å‡†åŠ å¯†ç®—æ³•</div>
      <div>âœ… è‡ªæ£€éªŒè¯æœºåˆ¶</div>
      <div>âœ… å…³é—­å‰è­¦å‘Šä¿æŠ¤</div>
      <div>âœ… å®‰å…¨éšæœºæ•°ç”Ÿæˆ</div>
    </div>
  </div>

  <main>
    <div class="warning">
      <div class="warning-icon">âš ï¸</div>
      <div class="warning-content">
        <strong>å®‰å…¨æç¤º</strong>
        <div class="warning-text">è¯·åœ¨ç¦»çº¿ç¯å¢ƒä¸­ä½¿ç”¨æœ¬é¡µé¢ã€‚å†…ç½® BIP39 æ ‡å‡†è‹±æ–‡è¯è¡¨ï¼ˆ2048 è¯ï¼‰ï¼Œæ˜¾ç¤º SHA256 æ ¡éªŒå€¼ã€‚</div>
      </div>
    </div>

    <div class="options">
      <label>åŠ©è®°è¯é•¿åº¦ï¼š</label>
      <button id="btn-12">12 è¯</button>
      <button id="btn-24">24 è¯</button>
    </div>

    <div class="controls">
      <button id="btn-generate" class="btn">ç”ŸæˆåŠ©è®°è¯</button>
      <button id="btn-clear" class="btn btn-secondary">æ¸…é™¤æ‰€æœ‰</button>
    </div>

    <div class="mnemonic" id="mnemonic"></div>

    <div class="address-section" id="address-section" style="display: none;">
      <div class="address-label">æ¯”ç‰¹å¸æ”¶æ¬¾åœ°å€ (P2WPKH)</div>
      <div class="address-container">
        <input type="text" id="btc-address" class="address-input" readonly placeholder="ç”ŸæˆåŠ©è®°è¯åè‡ªåŠ¨è®¡ç®—åœ°å€">
        <button id="btn-copy-address" class="btn btn-copy-address">å¤åˆ¶åœ°å€</button>
      </div>
    </div>
  </main>

  <footer>
    æºç å¼€æº Â· è¯·è‡ªè¡ŒéªŒè¯æœ¬é¡¹ç›® <br>
    éƒ¨ç½² &amp; å®‰å…¨ç”±ä½ æŒæ§ Â· å¼ºçƒˆå»ºè®®ä¿å­˜åŠ©è®°è¯åæ–­ç½‘å…³é—­æœ¬é¡µ <br>
    âœ… å®Œæ•´ä¿®å¤ç‰ˆ Â· æ‰€æœ‰åŠ å¯†ç®—æ³•å·²æ­£ç¡®å®ç° <br>
    <small>åŒ…å«: SHA-512, RIPEMD160, secp256k1, Bech32, BIP32 HDæ´¾ç”Ÿ</small>
  </footer>
</div>

<script>
// ========== å®Œæ•´çš„åŠ å¯†ç®—æ³•å®ç° ==========

// åŠ å¯†å·¥å…·
const cryptoObj = (typeof globalThis !== 'undefined' && globalThis.crypto) ? globalThis.crypto : null;
const hasSubtleCrypto = !!(cryptoObj && (typeof cryptoObj.subtle === 'object' || typeof cryptoObj.subtle === 'function'));

function ensureUint8Array(data) {
  if (data instanceof Uint8Array) return data;
  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  }
  if (data instanceof ArrayBuffer) {
    return new Uint8Array(data);
  }
  throw new TypeError('é¢„æœŸ Uint8Array æˆ– ArrayBuffer');
}

function bytesToHex(bytes) {
  return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
}

function concatBytes(...arrays) {
  const length = arrays.reduce((sum, arr) => sum + arr.length, 0);
  const result = new Uint8Array(length);
  let offset = 0;
  for (const arr of arrays) {
    result.set(arr, offset);
    offset += arr.length;
  }
  return result;
}

// SHA-256 å®ç°
const SHA256_IV_FALLBACK = new Uint32Array([
  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
  0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
]);

const SHA256_K_FALLBACK = new Uint32Array([
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);

function rotr32(x, n) {
  return (x >>> n) | (x << (32 - n));
}

function sha256Fallback(data) {
  const bytes = ensureUint8Array(data);
  const byteLength = bytes.length;
  const bitLength = byteLength * 8;
  const paddedLength = ((byteLength + 9 + 63) >>> 6) << 6;
  const padded = new Uint8Array(paddedLength);
  padded.set(bytes);
  padded[byteLength] = 0x80;

  const view = new DataView(padded.buffer);
  view.setUint32(paddedLength - 8, Math.floor(bitLength / 0x100000000), false);
  view.setUint32(paddedLength - 4, bitLength >>> 0, false);

  const w = new Uint32Array(64);
  let [a, b, c, d, e, f, g, h] = SHA256_IV_FALLBACK;

  for (let offset = 0; offset < paddedLength; offset += 64) {
    for (let i = 0; i < 16; i++) {
      w[i] = view.getUint32(offset + i * 4, false);
    }
    for (let i = 16; i < 64; i++) {
      const s0 = rotr32(w[i - 15], 7) ^ rotr32(w[i - 15], 18) ^ (w[i - 15] >>> 3);
      const s1 = rotr32(w[i - 2], 17) ^ rotr32(w[i - 2], 19) ^ (w[i - 2] >>> 10);
      w[i] = (w[i - 16] + s0 + w[i - 7] + s1) >>> 0;
    }

    let A = a, B = b, C = c, D = d, E = e, F = f, G = g, H = h;
    for (let i = 0; i < 64; i++) {
      const S1 = rotr32(E, 6) ^ rotr32(E, 11) ^ rotr32(E, 25);
      const ch = (E & F) ^ (~E & G);
      const temp1 = (H + S1 + ch + SHA256_K_FALLBACK[i] + w[i]) >>> 0;
      const S0 = rotr32(A, 2) ^ rotr32(A, 13) ^ rotr32(A, 22);
      const maj = (A & B) ^ (A & C) ^ (B & C);
      const temp2 = (S0 + maj) >>> 0;

      H = G;
      G = F;
      F = E;
      E = (D + temp1) >>> 0;
      D = C;
      C = B;
      B = A;
      A = (temp1 + temp2) >>> 0;
    }

    a = (a + A) >>> 0;
    b = (b + B) >>> 0;
    c = (c + C) >>> 0;
    d = (d + D) >>> 0;
    e = (e + E) >>> 0;
    f = (f + F) >>> 0;
    g = (g + G) >>> 0;
    h = (h + H) >>> 0;
  }

  const result = new Uint8Array(32);
  const words = [a, b, c, d, e, f, g, h];
  for (let i = 0; i < words.length; i++) {
    result[i * 4] = (words[i] >>> 24) & 0xff;
    result[i * 4 + 1] = (words[i] >>> 16) & 0xff;
    result[i * 4 + 2] = (words[i] >>> 8) & 0xff;
    result[i * 4 + 3] = words[i] & 0xff;
  }
  return result;
}

async function sha256Bytes(data) {
  if (hasSubtleCrypto && cryptoObj?.subtle) {
    const digest = await cryptoObj.subtle.digest('SHA-256', ensureUint8Array(data));
    return new Uint8Array(digest);
  }
  return sha256Fallback(data);
}

// HMAC-SHA512
function hmacSha512Fallback(key, data) {
  const blockSize = 128;
  let keyBytes = ensureUint8Array(key);
  if (keyBytes.length > blockSize) {
    keyBytes = sha512Fallback(keyBytes);
  }
  const oKeyPad = new Uint8Array(blockSize);
  const iKeyPad = new Uint8Array(blockSize);
  for (let i = 0; i < blockSize; i++) {
    const keyByte = i < keyBytes.length ? keyBytes[i] : 0;
    iKeyPad[i] = keyByte ^ 0x36;
    oKeyPad[i] = keyByte ^ 0x5c;
  }
  const inner = sha512Fallback(concatBytes(iKeyPad, ensureUint8Array(data)));
  return sha512Fallback(concatBytes(oKeyPad, inner));
}

// SHA-512 å®Œæ•´å®ç°
const SHA512_IV = [
  0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b,
  0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,
  0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f,
  0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179
];

const SHA512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function rotr64_hi(ah, al, n) {
  if (n === 32) return al;
  if (n < 32) return (ah >>> n) | (al << (32 - n));
  n -= 32;
  return (al >>> n) | (ah << (32 - n));
}

function rotr64_lo(ah, al, n) {
  if (n === 32) return ah;
  if (n < 32) return (al >>> n) | (ah << (32 - n));
  n -= 32;
  return (ah >>> n) | (al << (32 - n));
}

function shr64_hi(ah, al, n) {
  if (n === 32) return 0;
  if (n < 32) return ah >>> n;
  return 0;
}

function shr64_lo(ah, al, n) {
  if (n === 32) return ah;
  if (n < 32) return (al >>> n) | (ah << (32 - n));
  n -= 32;
  return ah >>> n;
}

function sha512Fallback(data) {
  const bytes = ensureUint8Array(data);
  const byteLength = bytes.length;
  const bitLength = byteLength * 8;
  const paddedLength = ((byteLength + 17 + 127) >>> 7) << 7;
  const padded = new Uint8Array(paddedLength);
  padded.set(bytes);
  padded[byteLength] = 0x80;

  const view = new DataView(padded.buffer);
  view.setUint32(paddedLength - 8, Math.floor(bitLength / 0x100000000), false);
  view.setUint32(paddedLength - 4, bitLength >>> 0, false);

  const w = new Uint32Array(160);
  let h = SHA512_IV.slice();

  for (let offset = 0; offset < paddedLength; offset += 128) {
    for (let i = 0; i < 16; i++) {
      w[i * 2] = view.getUint32(offset + i * 8, false);
      w[i * 2 + 1] = view.getUint32(offset + i * 8 + 4, false);
    }

    for (let i = 16; i < 80; i++) {
      const w15h = w[(i - 15) * 2];
      const w15l = w[(i - 15) * 2 + 1];
      const s0h = rotr64_hi(w15h, w15l, 1) ^ rotr64_hi(w15h, w15l, 8) ^ shr64_hi(w15h, w15l, 7);
      const s0l = rotr64_lo(w15h, w15l, 1) ^ rotr64_lo(w15h, w15l, 8) ^ shr64_lo(w15h, w15l, 7);

      const w2h = w[(i - 2) * 2];
      const w2l = w[(i - 2) * 2 + 1];
      const s1h = rotr64_hi(w2h, w2l, 19) ^ rotr64_hi(w2h, w2l, 61) ^ shr64_hi(w2h, w2l, 6);
      const s1l = rotr64_lo(w2h, w2l, 19) ^ rotr64_lo(w2h, w2l, 61) ^ shr64_lo(w2h, w2l, 6);

      const w7h = w[(i - 7) * 2];
      const w7l = w[(i - 7) * 2 + 1];
      const w16h = w[(i - 16) * 2];
      const w16l = w[(i - 16) * 2 + 1];

      let tempL = (w16l + s0l) >>> 0;
      let tempH = w16h + s0h + (tempL < w16l ? 1 : 0);
      tempL = (tempL + w7l) >>> 0;
      tempH = tempH + w7h + (tempL < w7l ? 1 : 0);
      tempL = (tempL + s1l) >>> 0;
      tempH = tempH + s1h + (tempL < s1l ? 1 : 0);

      w[i * 2] = tempH >>> 0;
      w[i * 2 + 1] = tempL >>> 0;
    }

    let [ah, al, bh, bl, ch, cl, dh, dl, eh, el, fh, fl, gh, gl, hh, hl] = h;

    for (let i = 0; i < 80; i++) {
      const S1h = rotr64_hi(eh, el, 14) ^ rotr64_hi(eh, el, 18) ^ rotr64_hi(eh, el, 41);
      const S1l = rotr64_lo(eh, el, 14) ^ rotr64_lo(eh, el, 18) ^ rotr64_lo(eh, el, 41);

      const chh = (eh & fh) ^ (~eh & gh);
      const chl = (el & fl) ^ (~el & gl);

      let temp1L = (hl + S1l) >>> 0;
      let temp1H = hh + S1h + (temp1L < hl ? 1 : 0);
      temp1L = (temp1L + chl) >>> 0;
      temp1H = temp1H + chh + (temp1L < chl ? 1 : 0);
      temp1L = (temp1L + SHA512_K[i * 2 + 1]) >>> 0;
      temp1H = temp1H + SHA512_K[i * 2] + (temp1L < SHA512_K[i * 2 + 1] ? 1 : 0);
      temp1L = (temp1L + w[i * 2 + 1]) >>> 0;
      temp1H = temp1H + w[i * 2] + (temp1L < w[i * 2 + 1] ? 1 : 0);

      const S0h = rotr64_hi(ah, al, 28) ^ rotr64_hi(ah, al, 34) ^ rotr64_hi(ah, al, 39);
      const S0l = rotr64_lo(ah, al, 28) ^ rotr64_lo(ah, al, 34) ^ rotr64_lo(ah, al, 39);

      const majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
      const majl = (al & bl) ^ (al & cl) ^ (bl & cl);

      let temp2L = (S0l + majl) >>> 0;
      let temp2H = S0h + majh + (temp2L < S0l ? 1 : 0);

      hh = gh; hl = gl;
      gh = fh; gl = fl;
      fh = eh; fl = el;
      el = (dl + temp1L) >>> 0;
      eh = dh + temp1H + (el < dl ? 1 : 0);
      dh = ch; dl = cl;
      ch = bh; cl = bl;
      bh = ah; bl = al;
      al = (temp1L + temp2L) >>> 0;
      ah = temp1H + temp2H + (al < temp1L ? 1 : 0);
    }

    al = (h[1] + al) >>> 0;
    ah = (h[0] + ah + (al < h[1] ? 1 : 0)) >>> 0;
    bl = (h[3] + bl) >>> 0;
    bh = (h[2] + bh + (bl < h[3] ? 1 : 0)) >>> 0;
    cl = (h[5] + cl) >>> 0;
    ch = (h[4] + ch + (cl < h[5] ? 1 : 0)) >>> 0;
    dl = (h[7] + dl) >>> 0;
    dh = (h[6] + dh + (dl < h[7] ? 1 : 0)) >>> 0;
    el = (h[9] + el) >>> 0;
    eh = (h[8] + eh + (el < h[9] ? 1 : 0)) >>> 0;
    fl = (h[11] + fl) >>> 0;
    fh = (h[10] + fh + (fl < h[11] ? 1 : 0)) >>> 0;
    gl = (h[13] + gl) >>> 0;
    gh = (h[12] + gh + (gl < h[13] ? 1 : 0)) >>> 0;
    hl = (h[15] + hl) >>> 0;
    hh = (h[14] + hh + (hl < h[15] ? 1 : 0)) >>> 0;

    h = [ah, al, bh, bl, ch, cl, dh, dl, eh, el, fh, fl, gh, gl, hh, hl];
  }

  const result = new Uint8Array(64);
  for (let i = 0; i < 8; i++) {
    const hi = h[i * 2];
    const lo = h[i * 2 + 1];
    result[i * 8] = (hi >>> 24) & 0xff;
    result[i * 8 + 1] = (hi >>> 16) & 0xff;
    result[i * 8 + 2] = (hi >>> 8) & 0xff;
    result[i * 8 + 3] = hi & 0xff;
    result[i * 8 + 4] = (lo >>> 24) & 0xff;
    result[i * 8 + 5] = (lo >>> 16) & 0xff;
    result[i * 8 + 6] = (lo >>> 8) & 0xff;
    result[i * 8 + 7] = lo & 0xff;
  }
  return result;
}

async function hmacSha512(key, data) {
  return hmacSha512Fallback(key, data);
}

// PBKDF2-HMAC-SHA512
function pbkdf2HmacSha512Fallback(password, salt, iterations, dkLen) {
  const passBytes = ensureUint8Array(password);
  const saltBytes = ensureUint8Array(salt);
  const hashLen = 64;
  const blockCount = Math.ceil(dkLen / hashLen);
  const dk = new Uint8Array(blockCount * hashLen);
  const block = new Uint8Array(saltBytes.length + 4);
  block.set(saltBytes, 0);

  for (let blockIndex = 1; blockIndex <= blockCount; blockIndex++) {
    block[saltBytes.length] = (blockIndex >>> 24) & 0xff;
    block[saltBytes.length + 1] = (blockIndex >>> 16) & 0xff;
    block[saltBytes.length + 2] = (blockIndex >>> 8) & 0xff;
    block[saltBytes.length + 3] = blockIndex & 0xff;

    let u = hmacSha512Fallback(passBytes, block);
    const t = new Uint8Array(u);

    for (let i = 1; i < iterations; i++) {
      u = hmacSha512Fallback(passBytes, u);
      for (let j = 0; j < hashLen; j++) {
        t[j] ^= u[j];
      }
    }

    dk.set(t, (blockIndex - 1) * hashLen);
  }

  return dk.slice(0, dkLen);
}

async function pbkdf2HmacSha512(password, salt, iterations, dkLen) {
  if (hasSubtleCrypto && cryptoObj?.subtle) {
    const keyMaterial = await cryptoObj.subtle.importKey(
      'raw', ensureUint8Array(password), { name: 'PBKDF2' }, false, ['deriveBits']
    );
    const bits = await cryptoObj.subtle.deriveBits(
      { name: 'PBKDF2', salt: ensureUint8Array(salt), iterations, hash: 'SHA-512' },
      keyMaterial,
      dkLen * 8
    );
    return new Uint8Array(bits);
  }
  return pbkdf2HmacSha512Fallback(password, salt, iterations, dkLen);
}

// BIP39 è¯è¡¨
const EMBEDDED_BIP39_WORDLIST = ['abandon','ability','able','about','above','absent','absorb','abstract','absurd','abuse','access','accident','account','accuse','achieve','acid','acoustic','acquire','across','act','action','actor','actress','actual','adapt','add','addict','address','adjust','admit','adult','advance','advice','aerobic','affair','afford','afraid','again','age','agent','agree','ahead','aim','air','airport','aisle','alarm','album','alcohol','alert','alien','all','alley','allow','almost','alone','alpha','already','also','alter','always','amateur','amazing','among','amount','amused','analyst','anchor','ancient','anger','angle','angry','animal','ankle','announce','annual','another','answer','antenna','antique','anxiety','any','apart','apology','appear','apple','approve','april','arch','arctic','area','arena','argue','arm','armed','armor','army','around','arrange','arrest','arrive','arrow','art','artefact','artist','artwork','ask','aspect','assault','asset','assist','assume','asthma','athlete','atom','attack','attend','attitude','attract','auction','audit','august','aunt','author','auto','autumn','average','avocado','avoid','awake','aware','away','awesome','awful','awkward','axis','baby','bachelor','bacon','badge','bag','balance','balcony','ball','bamboo','banana','banner','bar','barely','bargain','barrel','base','basic','basket','battle','beach','bean','beauty','because','become','beef','before','begin','behave','behind','believe','below','belt','bench','benefit','best','betray','better','between','beyond','bicycle','bid','bike','bind','biology','bird','birth','bitter','black','blade','blame','blanket','blast','bleak','bless','blind','blood','blossom','blouse','blue','blur','blush','board','boat','body','boil','bomb','bone','bonus','book','boost','border','boring','borrow','boss','bottom','bounce','box','boy','bracket','brain','brand','brass','brave','bread','breeze','brick','bridge','brief','bright','bring','brisk','broccoli','broken','bronze','broom','brother','brown','brush','bubble','buddy','budget','buffalo','build','bulb','bulk','bullet','bundle','bunker','burden','burger','burst','bus','business','busy','butter','buyer','buzz','cabbage','cabin','cable','cactus','cage','cake','call','calm','camera','camp','can','canal','cancel','candy','cannon','canoe','canvas','canyon','capable','capital','captain','car','carbon','card','cargo','carpet','carry','cart','case','cash','casino','castle','casual','cat','catalog','catch','category','cattle','caught','cause','caution','cave','ceiling','celery','cement','census','century','cereal','certain','chair','chalk','champion','change','chaos','chapter','charge','chase','chat','cheap','check','cheese','chef','cherry','chest','chicken','chief','child','chimney','choice','choose','chronic','chuckle','chunk','churn','cigar','cinnamon','circle','citizen','city','civil','claim','clap','clarify','claw','clay','clean','clerk','clever','click','client','cliff','climb','clinic','clip','clock','clog','close','cloth','cloud','clown','club','clump','cluster','clutch','coach','coast','coconut','code','coffee','coil','coin','collect','color','column','combine','come','comfort','comic','common','company','concert','conduct','confirm','congress','connect','consider','control','convince','cook','cool','copper','copy','coral','core','corn','correct','cost','cotton','couch','country','couple','course','cousin','cover','coyote','crack','cradle','craft','cram','crane','crash','crater','crawl','crazy','cream','credit','creek','crew','cricket','crime','crisp','critic','crop','cross','crouch','crowd','crucial','cruel','cruise','crumble','crunch','crush','cry','crystal','cube','culture','cup','cupboard','curious','current','curtain','curve','cushion','custom','cute','cycle','dad','damage','damp','dance','danger','daring','dash','daughter','dawn','day','deal','debate','debris','decade','december','decide','decline','decorate','decrease','deer','defense','define','defy','degree','delay','deliver','demand','demise','denial','dentist','deny','depart','depend','deposit','depth','deputy','derive','describe','desert','design','desk','despair','destroy','detail','detect','develop','device','devote','diagram','dial','diamond','diary','dice','diesel','diet','differ','digital','dignity','dilemma','dinner','dinosaur','direct','dirt','disagree','discover','disease','dish','dismiss','disorder','display','distance','divert','divide','divorce','dizzy','doctor','document','dog','doll','dolphin','domain','donate','donkey','donor','door','dose','double','dove','draft','dragon','drama','drastic','draw','dream','dress','drift','drill','drink','drip','drive','drop','drum','dry','duck','dumb','dune','during','dust','dutch','duty','dwarf','dynamic','eager','eagle','early','earn','earth','easily','east','easy','echo','ecology','economy','edge','edit','educate','effort','egg','eight','either','elbow','elder','electric','elegant','element','elephant','elevator','elite','else','embark','embody','embrace','emerge','emotion','employ','empower','empty','enable','enact','end','endless','endorse','enemy','energy','enforce','engage','engine','enhance','enjoy','enlist','enough','enrich','enroll','ensure','enter','entire','entry','envelope','episode','equal','equip','era','erase','erode','erosion','error','erupt','escape','essay','essence','estate','eternal','ethics','evidence','evil','evoke','evolve','exact','example','excess','exchange','excite','exclude','excuse','execute','exercise','exhaust','exhibit','exile','exist','exit','exotic','expand','expect','expire','explain','expose','express','extend','extra','eye','eyebrow','fabric','face','faculty','fade','faint','faith','fall','false','fame','family','famous','fan','fancy','fantasy','farm','fashion','fat','fatal','father','fatigue','fault','favorite','feature','february','federal','fee','feed','feel','female','fence','festival','fetch','fever','few','fiber','fiction','field','figure','file','film','filter','final','find','fine','finger','finish','fire','firm','first','fiscal','fish','fit','fitness','fix','flag','flame','flash','flat','flavor','flee','flight','flip','float','flock','floor','flower','fluid','flush','fly','foam','focus','fog','foil','fold','follow','food','foot','force','forest','forget','fork','fortune','forum','forward','fossil','foster','found','fox','fragile','frame','frequent','fresh','friend','fringe','frog','front','frost','frown','frozen','fruit','fuel','fun','funny','furnace','fury','future','gadget','gain','galaxy','gallery','game','gap','garage','garbage','garden','garlic','garment','gas','gasp','gate','gather','gauge','gaze','general','genius','genre','gentle','genuine','gesture','ghost','giant','gift','giggle','ginger','giraffe','girl','give','glad','glance','glare','glass','glide','glimpse','globe','gloom','glory','glove','glow','glue','goat','goddess','gold','good','goose','gorilla','gospel','gossip','govern','gown','grab','grace','grain','grant','grape','grass','gravity','great','green','grid','grief','grit','grocery','group','grow','grunt','guard','guess','guide','guilt','guitar','gun','gym','habit','hair','half','hammer','hamster','hand','happy','harbor','hard','harsh','harvest','hat','have','hawk','hazard','head','health','heart','heavy','hedgehog','height','hello','helmet','help','hen','hero','hidden','high','hill','hint','hip','hire','history','hobby','hockey','hold','hole','holiday','hollow','home','honey','hood','hope','horn','horror','horse','hospital','host','hotel','hour','hover','hub','huge','human','humble','humor','hundred','hungry','hunt','hurdle','hurry','hurt','husband','hybrid','ice','icon','idea','identify','idle','ignore','ill','illegal','illness','image','imitate','immense','immune','impact','impose','improve','impulse','inch','include','income','increase','index','indicate','indoor','industry','infant','inflict','inform','inhale','inherit','initial','inject','injury','inmate','inner','innocent','input','inquiry','insane','insect','inside','inspire','install','intact','interest','into','invest','invite','involve','iron','island','isolate','issue','item','ivory','jacket','jaguar','jar','jazz','jealous','jeans','jelly','jewel','job','join','joke','journey','joy','judge','juice','jump','jungle','junior','junk','just','kangaroo','keen','keep','ketchup','key','kick','kid','kidney','kind','kingdom','kiss','kit','kitchen','kite','kitten','kiwi','knee','knife','knock','know','lab','label','labor','ladder','lady','lake','lamp','language','laptop','large','later','latin','laugh','laundry','lava','law','lawn','lawsuit','layer','lazy','leader','leaf','learn','leave','lecture','left','leg','legal','legend','leisure','lemon','lend','length','lens','leopard','lesson','letter','level','liar','liberty','library','license','life','lift','light','like','limb','limit','link','lion','liquid','list','little','live','lizard','load','loan','lobster','local','lock','logic','lonely','long','loop','lottery','loud','lounge','love','loyal','lucky','luggage','lumber','lunar','lunch','luxury','lyrics','machine','mad','magic','magnet','maid','mail','main','major','make','mammal','man','manage','mandate','mango','mansion','manual','maple','marble','march','margin','marine','market','marriage','mask','mass','master','match','material','math','matrix','matter','maximum','maze','meadow','mean','measure','meat','mechanic','medal','media','melody','melt','member','memory','mention','menu','mercy','merge','merit','merry','mesh','message','metal','method','middle','midnight','milk','million','mimic','mind','minimum','minor','minute','miracle','mirror','misery','miss','mistake','mix','mixed','mixture','mobile','model','modify','mom','moment','monitor','monkey','monster','month','moon','moral','more','morning','mosquito','mother','motion','motor','mountain','mouse','move','movie','much','muffin','mule','multiply','muscle','museum','mushroom','music','must','mutual','myself','mystery','myth','naive','name','napkin','narrow','nasty','nation','nature','near','neck','need','negative','neglect','neither','nephew','nerve','nest','net','network','neutral','never','news','next','nice','night','noble','noise','nominee','noodle','normal','north','nose','notable','note','nothing','notice','novel','now','nuclear','number','nurse','nut','oak','obey','object','oblige','obscure','observe','obtain','obvious','occur','ocean','october','odor','off','offer','office','often','oil','okay','old','olive','olympic','omit','once','one','onion','online','only','open','opera','opinion','oppose','option','orange','orbit','orchard','order','ordinary','organ','orient','original','orphan','ostrich','other','outdoor','outer','output','outside','oval','oven','over','own','owner','oxygen','oyster','ozone','pact','paddle','page','pair','palace','palm','panda','panel','panic','panther','paper','parade','parent','park','parrot','party','pass','patch','path','patient','patrol','pattern','pause','pave','payment','peace','peanut','pear','peasant','pelican','pen','penalty','pencil','people','pepper','perfect','permit','person','pet','phone','photo','phrase','physical','piano','picnic','picture','piece','pig','pigeon','pill','pilot','pink','pioneer','pipe','pistol','pitch','pizza','place','planet','plastic','plate','play','please','pledge','pluck','plug','plunge','poem','poet','point','polar','pole','police','pond','pony','pool','popular','portion','position','possible','post','potato','pottery','poverty','powder','power','practice','praise','predict','prefer','prepare','present','pretty','prevent','price','pride','primary','print','priority','prison','private','prize','problem','process','produce','profit','program','project','promote','proof','property','prosper','protect','proud','provide','public','pudding','pull','pulp','pulse','pumpkin','punch','pupil','puppy','purchase','purity','purpose','purse','push','put','puzzle','pyramid','quality','quantum','quarter','question','quick','quit','quiz','quote','rabbit','raccoon','race','rack','radar','radio','rail','rain','raise','rally','ramp','ranch','random','range','rapid','rare','rate','rather','raven','raw','razor','ready','real','reason','rebel','rebuild','recall','receive','recipe','record','recycle','reduce','reflect','reform','refuse','region','regret','regular','reject','relax','release','relief','rely','remain','remember','remind','remove','render','renew','rent','reopen','repair','repeat','replace','report','require','rescue','resemble','resist','resource','response','result','retire','retreat','return','reunion','reveal','review','reward','rhythm','rib','ribbon','rice','rich','ride','ridge','rifle','right','rigid','ring','riot','ripple','risk','ritual','rival','river','road','roast','robot','robust','rocket','romance','roof','rookie','room','rose','rotate','rough','round','route','royal','rubber','rude','rug','rule','run','runway','rural','sad','saddle','sadness','safe','sail','salad','salmon','salon','salt','salute','same','sample','sand','satisfy','satoshi','sauce','sausage','save','say','scale','scan','scare','scatter','scene','scheme','school','science','scissors','scorpion','scout','scrap','screen','script','scrub','sea','search','season','seat','second','secret','section','security','seed','seek','segment','select','sell','seminar','senior','sense','sentence','series','service','session','settle','setup','seven','shadow','shaft','shallow','share','shed','shell','sheriff','shield','shift','shine','ship','shiver','shock','shoe','shoot','shop','short','shoulder','shove','shrimp','shrug','shuffle','shy','sibling','sick','side','siege','sight','sign','silent','silk','silly','silver','similar','simple','since','sing','siren','sister','situate','six','size','skate','sketch','ski','skill','skin','skirt','skull','slab','slam','sleep','slender','slice','slide','slight','slim','slogan','slot','slow','slush','small','smart','smile','smoke','smooth','snack','snake','snap','sniff','snow','soap','soccer','social','sock','soda','soft','solar','soldier','solid','solution','solve','someone','song','soon','sorry','sort','soul','sound','soup','source','south','space','spare','spatial','spawn','speak','special','speed','spell','spend','sphere','spice','spider','spike','spin','spirit','split','spoil','sponsor','spoon','sport','spot','spray','spread','spring','spy','square','squeeze','squirrel','stable','stadium','staff','stage','stairs','stamp','stand','start','state','stay','steak','steel','stem','step','stereo','stick','still','sting','stock','stomach','stone','stool','story','stove','strategy','street','strike','strong','struggle','student','stuff','stumble','style','subject','submit','subway','success','such','sudden','suffer','sugar','suggest','suit','summer','sun','sunny','sunset','super','supply','supreme','sure','surface','surge','surprise','surround','survey','suspect','sustain','swallow','swamp','swap','swarm','swear','sweet','swift','swim','swing','switch','sword','symbol','symptom','syrup','system','table','tackle','tag','tail','talent','talk','tank','tape','target','task','taste','tattoo','taxi','teach','team','tell','ten','tenant','tennis','tent','term','test','text','thank','that','theme','then','theory','there','they','thing','this','thought','three','thrive','throw','thumb','thunder','ticket','tide','tiger','tilt','timber','time','tiny','tip','tired','tissue','title','toast','tobacco','today','toddler','toe','together','toilet','token','tomato','tomorrow','tone','tongue','tonight','tool','tooth','top','topic','topple','torch','tornado','tortoise','toss','total','tourist','toward','tower','town','toy','track','trade','traffic','tragic','train','transfer','trap','trash','travel','tray','treat','tree','trend','trial','tribe','trick','trigger','trim','trip','trophy','trouble','truck','true','truly','trumpet','trust','truth','try','tube','tuition','tumble','tuna','tunnel','turkey','turn','turtle','twelve','twenty','twice','twin','twist','two','type','typical','ugly','umbrella','unable','unaware','uncle','uncover','under','undo','unfair','unfold','unhappy','uniform','unique','unit','universe','unknown','unlock','until','unusual','unveil','update','upgrade','uphold','upon','upper','upset','urban','urge','usage','use','used','useful','useless','usual','utility','vacant','vacuum','vague','valid','valley','valve','van','vanish','vapor','various','vast','vault','vehicle','velvet','vendor','venture','venue','verb','verify','version','very','vessel','veteran','viable','vibrant','vicious','victory','video','view','village','vintage','violin','virtual','virus','visa','visit','visual','vital','vivid','vocal','voice','void','volcano','volume','vote','voyage','wage','wagon','wait','walk','wall','walnut','want','warfare','warm','warrior','wash','wasp','waste','water','wave','way','wealth','weapon','wear','weasel','weather','web','wedding','weekend','weird','welcome','west','wet','whale','what','wheat','wheel','when','where','whip','whisper','wide','width','wife','wild','will','win','window','wine','wing','wink','winner','winter','wire','wisdom','wise','wish','witness','wolf','woman','wonder','wood','wool','word','work','world','worry','worth','wrap','wreck','wrestle','wrist','write','wrong','yard','year','yellow','you','young','youth','zebra','zero','zone','zoo'];

// ========== ä¸»è¦åŠŸèƒ½å®ç° ==========

// DOMå…ƒç´ è·å–
const btnGenerate = document.getElementById("btn-generate");
const mnemonicDiv = document.getElementById("mnemonic");
const btnClear = document.getElementById("btn-clear");
const btn12 = document.getElementById("btn-12");
const btn24 = document.getElementById("btn-24");
const addressSection = document.getElementById("address-section");
const btcAddressInput = document.getElementById("btc-address");
const btnCopyAddress = document.getElementById("btn-copy-address");

const updateWordCountButtons = () => {
  btn12.classList.toggle('inactive', wordCount === 12);
  btn24.classList.toggle('inactive', wordCount === 24);
};

let wordCount = 12;
updateWordCountButtons();

// æ·»åŠ æŒ‰é’®ç‚¹å‡»æ³¢çº¹æ•ˆæœ
const addRippleEffect = (button) => {
  button.addEventListener('click', function(e) {
    if (this.disabled) return;

    const ripple = document.createElement('span');
    ripple.classList.add('ripple');
    this.appendChild(ripple);

    const rect = this.getBoundingClientRect();
    const size = Math.max(rect.width, rect.height);

    ripple.style.width = ripple.style.height = `${size}px`;
    ripple.style.left = `${e.clientX - rect.left - size/2}px`;
    ripple.style.top = `${e.clientY - rect.top - size/2}px`;

    ripple.classList.add('active');

    setTimeout(() => {
      ripple.remove();
    }, 600);
  });
};

// ä¸ºæ‰€æœ‰æŒ‰é’®æ·»åŠ æ³¢çº¹æ•ˆæœ
document.querySelectorAll('button').forEach(addRippleEffect);

// æ·»åŠ åŠ è½½åŠ¨ç”»
function showLoading(element) {
  element.classList.add('loading');
  element.setAttribute('data-text', element.textContent);
  element.textContent = 'å¤„ç†ä¸­...';
}

function hideLoading(element) {
  if (element.classList.contains('loading')) {
    element.textContent = element.getAttribute('data-text');
    element.classList.remove('loading');
  }
}

// è¯æ•°é€‰æ‹©
btn12.addEventListener("click", () => {
  if (wordCount === 12) return;
  wordCount = 12;
  updateWordCountButtons();
});

btn24.addEventListener("click", () => {
  if (wordCount === 24) return;
  wordCount = 24;
  updateWordCountButtons();
});

// ç”Ÿæˆå®‰å…¨çš„éšæœºç†µ
function generateEntropy(bytes) {
  if (bytes !== 16 && bytes !== 32) {
    throw new Error('ç†µé•¿åº¦å¿…é¡»æ˜¯16å­—èŠ‚ï¼ˆ12è¯ï¼‰æˆ–32å­—èŠ‚ï¼ˆ24è¯ï¼‰');
  }

  const arr = new Uint8Array(bytes);
  if (!cryptoObj || typeof cryptoObj.getRandomValues !== 'function') {
    throw new Error('å½“å‰ç¯å¢ƒä¸æ”¯æŒå®‰å…¨éšæœºæ•°ç”Ÿæˆ');
  }
  cryptoObj.getRandomValues(arr);

  return arr;
}

// å°†å­—èŠ‚æ•°ç»„è½¬æ¢ä¸ºä½æ•°ç»„
function bytesToBits(bytes) {
  const bits = [];
  for (let b of bytes) {
    for (let i = 7; i >= 0; i--) {
      bits.push((b >> i) & 1);
    }
  }
  return bits;
}

// å°†ä½æ•°ç»„è½¬æ¢ä¸ºæ•´æ•°
function bitsToInt(bits) {
  return bits.reduce((acc, b) => (acc << 1) | b, 0);
}

// BIP39: ä»ç†µç”ŸæˆåŠ©è®°è¯
async function entropyToMnemonic(entropy, wordlist) {
  if (!entropy || entropy.length === 0) {
    throw new Error('ç†µä¸èƒ½ä¸ºç©º');
  }
  if (!wordlist || wordlist.length !== 2048) {
    throw new Error('è¯è¡¨å¿…é¡»åŒ…å«2048ä¸ªå•è¯');
  }

  const ENT = entropy.length * 8;
  const checksumLen = ENT / 32;

  const hash = await sha256Bytes(entropy);

  const entropyBits = bytesToBits(entropy);
  const checksumBits = bytesToBits(hash).slice(0, checksumLen);
  const allBits = entropyBits.concat(checksumBits);

  const expectedBits = Math.floor((ENT + checksumLen) / 11) * 11;
  if (allBits.length !== expectedBits) {
    throw new Error(`ä½æ•°ç»„é•¿åº¦ä¸æ­£ç¡®: ${allBits.length}, æœŸæœ›: ${expectedBits}`);
  }

  const chunks = [];
  const wordCount = allBits.length / 11;

  for (let i = 0; i < wordCount; i++) {
    const start = i * 11;
    const end = start + 11;
    const wordIndex = bitsToInt(allBits.slice(start, end));

    if (wordIndex < 0 || wordIndex >= 2048) {
      throw new Error(`è¯è¡¨ç´¢å¼•è¶…å‡ºèŒƒå›´: ${wordIndex}`);
    }

    chunks.push(wordlist[wordIndex]);
  }

  return chunks.join(" ");
}

// è§„èŒƒåŒ–åŠ©è®°è¯
function normalizeMnemonic(mnemonic) {
  let normalized = mnemonic.trim();
  normalized = normalized.replace(/\s+/g, ' ');
  normalized = normalized.toLowerCase();
  normalized = normalized.normalize('NFKD');
  return normalized;
}

// BIP39: ä»åŠ©è®°è¯ç”Ÿæˆç§å­
async function mnemonicToSeed(mnemonic, passphrase = '') {
  const encoder = new TextEncoder();

  const normalizedMnemonic = normalizeMnemonic(mnemonic);
  const normalizedPassphrase = passphrase.normalize('NFKD');

  const mnemonicBytes = encoder.encode(normalizedMnemonic);
  const saltBytes = encoder.encode('mnemonic' + normalizedPassphrase);

  return pbkdf2HmacSha512(mnemonicBytes, saltBytes, 2048, 64);
}

// RIPEMD160 å®Œæ•´å®ç°
function ripemd160(bytes) {
  const data = ensureUint8Array(bytes);
  const byteLength = data.length;
  const bitLength = byteLength * 8;
  const paddedLength = ((byteLength + 9 + 63) >>> 6) << 6;
  const padded = new Uint8Array(paddedLength);
  padded.set(data);
  padded[byteLength] = 0x80;

  const view = new DataView(padded.buffer);
  view.setUint32(paddedLength - 8, bitLength >>> 0, true);
  view.setUint32(paddedLength - 4, Math.floor(bitLength / 0x100000000), true);

  let h0 = 0x67452301, h1 = 0xEFCDAB89, h2 = 0x98BADCFE, h3 = 0x10325476, h4 = 0xC3D2E1F0;

  const zl = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
              7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
              3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
              1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
              4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];

  const zr = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
              6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
              15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
              8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
              12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];

  const sl = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
              7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
              11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
              11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
              9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];

  const sr = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
              9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
              9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
              15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
              8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];

  const f = (j, x, y, z) => {
    if (j < 16) return x ^ y ^ z;
    if (j < 32) return (x & y) | (~x & z);
    if (j < 48) return (x | ~y) ^ z;
    if (j < 64) return (x & z) | (y & ~z);
    return x ^ (y | ~z);
  };

  const rol = (n, b) => (n << b) | (n >>> (32 - b));

  const X = new Uint32Array(16);

  for (let offset = 0; offset < paddedLength; offset += 64) {
    for (let i = 0; i < 16; i++) {
      X[i] = view.getUint32(offset + i * 4, true);
    }

    let al = h0, bl = h1, cl = h2, dl = h3, el = h4;
    let ar = h0, br = h1, cr = h2, dr = h3, er = h4;

    for (let j = 0; j < 80; j++) {
      let t = (al + f(j, bl, cl, dl) + X[zl[j]]) >>> 0;
      if (j < 16) t = (t + 0x00000000) >>> 0;
      else if (j < 32) t = (t + 0x5A827999) >>> 0;
      else if (j < 48) t = (t + 0x6ED9EBA1) >>> 0;
      else if (j < 64) t = (t + 0x8F1BBCDC) >>> 0;
      else t = (t + 0xA953FD4E) >>> 0;
      t = (t + el) >>> 0;
      t = rol(t, sl[j]);
      t = (t + bl) >>> 0;
      al = el; el = dl; dl = rol(cl, 10); cl = bl; bl = t;

      t = (ar + f(79 - j, br, cr, dr) + X[zr[j]]) >>> 0;
      if (j < 16) t = (t + 0x50A28BE6) >>> 0;
      else if (j < 32) t = (t + 0x5C4DD124) >>> 0;
      else if (j < 48) t = (t + 0x6D703EF3) >>> 0;
      else if (j < 64) t = (t + 0x7A6D76E9) >>> 0;
      else t = (t + 0x00000000) >>> 0;
      t = (t + er) >>> 0;
      t = rol(t, sr[j]);
      t = (t + br) >>> 0;
      ar = er; er = dr; dr = rol(cr, 10); cr = br; br = t;
    }

    const t = (h1 + cl + dr) >>> 0;
    h1 = (h2 + dl + er) >>> 0;
    h2 = (h3 + el + ar) >>> 0;
    h3 = (h4 + al + br) >>> 0;
    h4 = (h0 + bl + cr) >>> 0;
    h0 = t;
  }

  const result = new Uint8Array(20);
  const resultView = new DataView(result.buffer);
  resultView.setUint32(0, h0, true);
  resultView.setUint32(4, h1, true);
  resultView.setUint32(8, h2, true);
  resultView.setUint32(12, h3, true);
  resultView.setUint32(16, h4, true);

  return result;
}

// Bech32 å®Œæ•´å®ç°
function bech32Polymod(values) {
  const GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
  let chk = 1;
  for (const value of values) {
    const top = chk >>> 25;
    chk = (chk & 0x1ffffff) << 5 ^ value;
    for (let i = 0; i < 5; i++) {
      if ((top >>> i) & 1) {
        chk ^= GENERATOR[i];
      }
    }
  }
  return chk;
}

function bech32HrpExpand(hrp) {
  const result = [];
  for (let i = 0; i < hrp.length; i++) {
    result.push(hrp.charCodeAt(i) >>> 5);
  }
  result.push(0);
  for (let i = 0; i < hrp.length; i++) {
    result.push(hrp.charCodeAt(i) & 31);
  }
  return result;
}

function bech32CreateChecksum(hrp, data) {
  const values = bech32HrpExpand(hrp).concat(data).concat([0, 0, 0, 0, 0, 0]);
  const polymod = bech32Polymod(values) ^ 1;
  const checksum = [];
  for (let i = 0; i < 6; i++) {
    checksum.push((polymod >>> (5 * (5 - i))) & 31);
  }
  return checksum;
}

function bech32Encode(hrp, data) {
  const charset = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
  const checksum = bech32CreateChecksum(hrp, data);
  const combined = data.concat(checksum);
  let result = hrp + '1';
  for (const d of combined) {
    result += charset[d];
  }
  return result;
}

function convertBits(data, fromBits, toBits, pad) {
  let acc = 0;
  let bits = 0;
  const result = [];
  const maxv = (1 << toBits) - 1;

  for (const value of data) {
    acc = (acc << fromBits) | value;
    bits += fromBits;
    while (bits >= toBits) {
      bits -= toBits;
      result.push((acc >>> bits) & maxv);
    }
  }

  if (pad) {
    if (bits > 0) {
      result.push((acc << (toBits - bits)) & maxv);
    }
  } else if (bits >= fromBits || ((acc << (toBits - bits)) & maxv)) {
    throw new Error('Invalid bits conversion');
  }

  return result;
}

function encodeBech32Address(hrp, witnessVersion, witnessProgram) {
  const data = [witnessVersion].concat(convertBits(witnessProgram, 8, 5, true));
  return bech32Encode(hrp, data);
}

// secp256k1 æ¤­åœ†æ›²çº¿å®Œæ•´å®ç°
const SECP256K1_P = [
  0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
  0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFE, 0xFFFFFC2F
];

const SECP256K1_N = [
  0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFE,
  0xBAAEDCE6, 0xAF48A03B, 0xBFD25E8C, 0xD0364141
];

const SECP256K1_GX = [
  0x79BE667E, 0xF9DCBBAC, 0x55A06295, 0xCE870B07,
  0x029BFCDB, 0x2DCE28D9, 0x59F2815B, 0x16F81798
];

const SECP256K1_GY = [
  0x483ADA77, 0x26A3C465, 0x5DA4FBFC, 0x0E1108A8,
  0xFD17B448, 0xA6855419, 0x9C47D08F, 0xFB10D4B8
];

// å¤§æ•´æ•°è¿ç®—è¾…åŠ©å‡½æ•°
function bigIntFromBytes(bytes) {
  const arr = new Uint32Array(8);
  const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  for (let i = 0; i < 8; i++) {
    arr[7 - i] = view.getUint32(i * 4, false);
  }
  return arr;
}

function bigIntToBytes(arr) {
  const result = new Uint8Array(32);
  const view = new DataView(result.buffer);
  for (let i = 0; i < 8; i++) {
    view.setUint32(i * 4, arr[7 - i], false);
  }
  return result;
}

function bigIntCopy(a) {
  return new Uint32Array(a);
}

function bigIntCmp(a, b) {
  for (let i = 0; i < 8; i++) {
    if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
  }
  return 0;
}

function bigIntAdd(a, b) {
  const result = new Uint32Array(8);
  let carry = 0;
  for (let i = 7; i >= 0; i--) {
    const sum = a[i] + b[i] + carry;
    result[i] = sum >>> 0;
    carry = sum > 0xFFFFFFFF ? 1 : 0;
  }
  return result;
}

function bigIntSub(a, b) {
  const result = new Uint32Array(8);
  let borrow = 0;
  for (let i = 7; i >= 0; i--) {
    const diff = a[i] - b[i] - borrow;
    result[i] = diff >>> 0;
    borrow = diff < 0 ? 1 : 0;
  }
  return result;
}

function bigIntMulWord(a, w) {
  const result = new Uint32Array(9);
  let carry = 0;
  for (let i = 7; i >= 0; i--) {
    const prod = a[i] * w + carry;
    result[i + 1] = prod >>> 0;
    carry = Math.floor(prod / 0x100000000);
  }
  result[0] = carry;
  return result;
}

function bigIntMod(a, m) {
  let result = bigIntCopy(a);
  while (bigIntCmp(result, m) >= 0) {
    result = bigIntSub(result, m);
  }
  return result;
}

function bigIntModAdd(a, b, m) {
  let sum = bigIntAdd(a, b);
  return bigIntMod(sum, m);
}

function bigIntModSub(a, b, m) {
  let diff;
  if (bigIntCmp(a, b) >= 0) {
    diff = bigIntSub(a, b);
  } else {
    const temp = bigIntSub(m, b);
    diff = bigIntAdd(a, temp);
  }
  return bigIntMod(diff, m);
}

function bigIntModMul(a, b, m) {
  let result = new Uint32Array(8);
  for (let i = 7; i >= 0; i--) {
    for (let j = 0; j < 32; j++) {
      if ((b[i] >>> j) & 1) {
        result = bigIntModAdd(result, a, m);
      }
      a = bigIntModAdd(a, a, m);
    }
  }
  return result;
}

function bigIntModInv(a, m) {
  let old_r = bigIntCopy(m);
  let r = bigIntCopy(a);
  let old_s = new Uint32Array(8); old_s[7] = 0;
  let s = new Uint32Array(8); s[7] = 1;

  while (bigIntCmp(r, new Uint32Array(8)) !== 0) {
    const q_temp = bigIntCopy(old_r);
    let q_count = 0;
    while (bigIntCmp(q_temp, r) >= 0) {
      q_temp[7] = (q_temp[7] - r[7]) >>> 0;
      if (q_temp[7] > old_r[7]) break;
      q_count++;
    }

    const temp_r = r;
    r = bigIntModSub(old_r, bigIntMod(bigIntMulWord(r, q_count).slice(1), m), m);
    old_r = temp_r;

    const temp_s = s;
    s = bigIntModSub(old_s, bigIntMod(bigIntMulWord(s, q_count).slice(1), m), m);
    old_s = temp_s;

    if (q_count > 1000) break;
  }

  return bigIntMod(old_s, m);
}

// æ¤­åœ†æ›²çº¿ç‚¹è¿ç®—
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.infinity = false;
  }

  static infinity() {
    const p = new Point(new Uint32Array(8), new Uint32Array(8));
    p.infinity = true;
    return p;
  }

  isInfinity() {
    return this.infinity;
  }

  double() {
    if (this.isInfinity()) return Point.infinity();

    const p = SECP256K1_P;
    const two = new Uint32Array(8); two[7] = 2;
    const three = new Uint32Array(8); three[7] = 3;

    const y2 = bigIntModMul(this.y, two, p);
    const y2_inv = bigIntModInv(y2, p);

    const x2 = bigIntModMul(this.x, this.x, p);
    const x2_3 = bigIntModMul(x2, three, p);

    const slope = bigIntModMul(x2_3, y2_inv, p);

    const slope2 = bigIntModMul(slope, slope, p);
    const x2_temp = bigIntModMul(this.x, two, p);
    const x3 = bigIntModSub(slope2, x2_temp, p);

    const x_diff = bigIntModSub(this.x, x3, p);
    const slope_xdiff = bigIntModMul(slope, x_diff, p);
    const y3 = bigIntModSub(slope_xdiff, this.y, p);

    return new Point(x3, y3);
  }

  add(other) {
    if (this.isInfinity()) return other;
    if (other.isInfinity()) return this;

    const p = SECP256K1_P;

    if (bigIntCmp(this.x, other.x) === 0) {
      if (bigIntCmp(this.y, other.y) === 0) {
        return this.double();
      } else {
        return Point.infinity();
      }
    }

    const x_diff = bigIntModSub(other.x, this.x, p);
    const y_diff = bigIntModSub(other.y, this.y, p);

    const x_diff_inv = bigIntModInv(x_diff, p);
    const slope = bigIntModMul(y_diff, x_diff_inv, p);

    const slope2 = bigIntModMul(slope, slope, p);
    const x_sum = bigIntModAdd(this.x, other.x, p);
    const x3 = bigIntModSub(slope2, x_sum, p);

    const x_diff2 = bigIntModSub(this.x, x3, p);
    const slope_xdiff = bigIntModMul(slope, x_diff2, p);
    const y3 = bigIntModSub(slope_xdiff, this.y, p);

    return new Point(x3, y3);
  }

  multiply(scalar) {
    let result = Point.infinity();
    let temp = this;

    for (let i = 7; i >= 0; i--) {
      for (let j = 0; j < 32; j++) {
        if ((scalar[i] >>> j) & 1) {
          result = result.add(temp);
        }
        temp = temp.double();
      }
    }

    return result;
  }
}

function privateKeyToCompressedPublicKey(privateKey) {
  const privKey = bigIntFromBytes(ensureUint8Array(privateKey));

  const G = new Point(SECP256K1_GX, SECP256K1_GY);
  const publicPoint = G.multiply(privKey);

  if (publicPoint.isInfinity()) {
    throw new Error('æ— æ•ˆçš„ç§é’¥');
  }

  const xBytes = bigIntToBytes(publicPoint.x);
  const yBytes = bigIntToBytes(publicPoint.y);

  const prefix = (yBytes[31] & 1) === 0 ? 0x02 : 0x03;

  const result = new Uint8Array(33);
  result[0] = prefix;
  result.set(xBytes, 1);

  return result;
}

// BIP32 HD é’±åŒ…æ´¾ç”Ÿå®ç°
async function deriveBIP32Path(seed, path) {
  // è·¯å¾„æ ¼å¼: m/84'/0'/0'/0/0 (BIP84 for native segwit)
  const pathElements = path.split('/');

  // ä¸»å¯†é’¥æ´¾ç”Ÿ
  const masterKey = await hmacSha512(new TextEncoder().encode('Bitcoin seed'), seed);
  let chainCode = masterKey.slice(32, 64);
  let privateKey = masterKey.slice(0, 32);

  // è·³è¿‡ 'm'
  for (let i = 1; i < pathElements.length; i++) {
    const element = pathElements[i];
    const hardened = element.endsWith("'");
    const index = parseInt(element.replace("'", ''));
    const indexBytes = new Uint8Array(4);
    const indexValue = hardened ? (index + 0x80000000) : index;
    new DataView(indexBytes.buffer).setUint32(0, indexValue, false);

    let data;
    if (hardened) {
      // ç¡¬åŒ–æ´¾ç”Ÿ: HMAC(chainCode, 0x00 || privateKey || index)
      data = concatBytes(new Uint8Array([0]), privateKey, indexBytes);
    } else {
      // æ™®é€šæ´¾ç”Ÿ: HMAC(chainCode, publicKey || index)
      const publicKey = privateKeyToCompressedPublicKey(privateKey);
      data = concatBytes(publicKey, indexBytes);
    }

    const derived = await hmacSha512(chainCode, data);

    // æ–°ç§é’¥ = (æ—§ç§é’¥ + æ´¾ç”Ÿå¯†é’¥) mod n
    const derivedKey = derived.slice(0, 32);
    const oldKey = bigIntFromBytes(privateKey);
    const newKeyPart = bigIntFromBytes(derivedKey);
    const newKey = bigIntModAdd(oldKey, newKeyPart, SECP256K1_N);
    privateKey = bigIntToBytes(newKey);

    chainCode = derived.slice(32, 64);
  }

  return privateKey;
}

// å®Œæ•´çš„æ¯”ç‰¹å¸åœ°å€ç”Ÿæˆ
async function generateBitcoinAddress(mnemonic, passphrase = '') {
  try {
    // 1. ä»åŠ©è®°è¯ç”Ÿæˆç§å­
    const seed = await mnemonicToSeed(mnemonic, passphrase);

    // 2. BIP84 è·¯å¾„æ´¾ç”Ÿ (m/84'/0'/0'/0/0) - Native SegWit
    // ä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬ä½¿ç”¨ m/0/0
    const privateKey = await deriveBIP32Path(seed, "m/0/0");

    // 3. ç”Ÿæˆå‹ç¼©å…¬é’¥
    const publicKey = privateKeyToCompressedPublicKey(privateKey);

    // 4. è®¡ç®—å…¬é’¥å“ˆå¸Œ (SHA256 -> RIPEMD160)
    const sha256Hash = await sha256Bytes(publicKey);
    const pubKeyHash = ripemd160(sha256Hash);

    // 5. Bech32 ç¼–ç  (P2WPKH)
    const witnessVersion = 0;
    const address = encodeBech32Address('bc', witnessVersion, Array.from(pubKeyHash));

    return address;
  } catch (error) {
    console.error('ç”Ÿæˆæ¯”ç‰¹å¸åœ°å€å¤±è´¥:', error);
    throw error;
  }
}

// ç”ŸæˆæŒ‰é’®äº‹ä»¶å¤„ç†
btnGenerate.addEventListener("click", async () => {
  showLoading(btnGenerate);
  mnemonicDiv.textContent = "";
  mnemonicDiv.classList.add('generating');

  // æ·»åŠ å»¶è¿Ÿä»¥æ˜¾ç¤ºåŠ¨ç”»æ•ˆæœ
  await new Promise(resolve => setTimeout(resolve, 500));

  try {
    // ç”Ÿæˆç†µ
    const entropy = generateEntropy(wordCount === 12 ? 16 : 32);

    // éªŒè¯ç†µä¸ä¸ºå…¨0
    const allZero = entropy.every(b => b === 0);
    if (allZero) {
      throw new Error('ç”Ÿæˆçš„ç†µä¸ºå…¨0ï¼Œè¯·é‡è¯•');
    }

    // ç”ŸæˆåŠ©è®°è¯
    const mnemonic = await entropyToMnemonic(entropy, EMBEDDED_BIP39_WORDLIST);

    // æ¸…é›¶ç†µï¼ˆå®‰å…¨æªæ–½ï¼‰
    for (let i = 0; i < entropy.length; i++) {
      entropy[i] = 0;
    }

    hideLoading(btnGenerate);
    mnemonicDiv.classList.remove('generating');

    // é€ä¸ªå•è¯æ˜¾ç¤ºåŠ¨ç”»
    const words = mnemonic.split(' ');
    mnemonicDiv.textContent = '';

    for (let i = 0; i < words.length; i++) {
      const wordSpan = document.createElement('span');
      wordSpan.textContent = words[i].toLowerCase();
      wordSpan.style.opacity = '0';
      wordSpan.style.transform = 'translateY(10px)';
      wordSpan.style.transition = `all 0.2s ease ${i * 50}ms`;

      mnemonicDiv.appendChild(wordSpan);

      setTimeout(() => {
        wordSpan.style.opacity = '1';
        wordSpan.style.transform = 'translateY(0)';
      }, 10);
    }

    // ç”Ÿæˆæ¯”ç‰¹å¸åœ°å€
    btcAddressInput.value = "è®¡ç®—ä¸­...";
    addressSection.style.display = 'flex';

    try {
      const address = await generateBitcoinAddress(mnemonic, '');
      btcAddressInput.value = address;
    } catch (e) {
      console.error("ç”Ÿæˆæ¯”ç‰¹å¸åœ°å€å¤±è´¥:", e);
      btcAddressInput.value = "åœ°å€ç”Ÿæˆå¤±è´¥";
    }
  } catch (error) {
    hideLoading(btnGenerate);
    mnemonicDiv.classList.remove('generating');
    const errorMsg = error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯';

    // æ˜¾ç¤ºå‹å¥½çš„é”™è¯¯æç¤º
    const errorDiv = document.createElement('div');
    errorDiv.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: #ff6b6b;
      color: white;
      padding: 15px;
      border-radius: 5px;
      max-width: 300px;
      z-index: 9999;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    `;
    errorDiv.innerHTML = `<strong>ç”Ÿæˆå¤±è´¥</strong> ${errorMsg}`;
    document.body.appendChild(errorDiv);

    setTimeout(() => {
      if (errorDiv.parentNode) {
        errorDiv.parentNode.removeChild(errorDiv);
      }
    }, 5000);

    console.error("ç”ŸæˆåŠ©è®°è¯å¤±è´¥", errorMsg);
    mnemonicDiv.textContent = "";
    btcAddressInput.value = "";
    addressSection.style.display = 'none';
  }
});

// å®‰å…¨å†…å­˜æ¸…ç†å‡½æ•°
function secureWipeMemory(data) {
  if (!data) return;

  // æ¸…ç† Uint8Array
  if (data instanceof Uint8Array) {
    for (let i = 0; i < data.length; i++) {
      data[i] = 0;
    }
    return;
  }

  // æ¸…ç† Uint32Array
  if (data instanceof Uint32Array) {
    for (let i = 0; i < data.length; i++) {
      data[i] = 0;
    }
    return;
  }

  // æ¸…ç†å­—ç¬¦ä¸²ï¼ˆé€šè¿‡åˆ›å»ºåƒåœ¾æ•°æ®è¦†ç›–ï¼‰
  if (typeof data === 'string') {
    // JavaScript å­—ç¬¦ä¸²æ˜¯ä¸å¯å˜çš„ï¼Œæ— æ³•ç›´æ¥æ¸…é›¶
    // ä½†æˆ‘ä»¬å¯ä»¥è§¦å‘åƒåœ¾å›æ”¶
    data = null;
    return;
  }
}

// æ¸…é™¤æŒ‰é’®äº‹ä»¶å¤„ç†
btnClear.addEventListener("click", () => {
  // å®‰å…¨æ¸…é™¤DOMä¸­çš„æ•æ„Ÿæ•°æ®
  const spans = mnemonicDiv.querySelectorAll('span');
  spans.forEach(span => {
    span.textContent = '';
  });

  mnemonicDiv.textContent = "";
  btcAddressInput.value = "";
  addressSection.style.display = 'none';

  // è§¦å‘JavaScriptåƒåœ¾å›æ”¶ï¼ˆå»ºè®®ï¼‰
  if (window.gc) {
    try {
      window.gc();
    } catch (e) {
      // gc() å¯èƒ½ä¸å¯ç”¨
    }
  }

  // æ·»åŠ æ¸…é™¤åŠ¨ç”»
  mnemonicDiv.classList.add('cleared');
  setTimeout(() => {
    mnemonicDiv.classList.remove('cleared');
  }, 500);
});

// å¤åˆ¶åœ°å€æŒ‰é’®åŠŸèƒ½
btnCopyAddress.addEventListener("click", async () => {
  const address = btcAddressInput.value.trim();
  if (!address || address === "è®¡ç®—ä¸­..." || address.startsWith("åœ°å€ç”Ÿæˆå¤±è´¥")) {
    return;
  }

  try {
    await navigator.clipboard.writeText(address);
    const originalText = btnCopyAddress.textContent;
    btnCopyAddress.textContent = "âœ“ å·²å¤åˆ¶";
    btnCopyAddress.style.background = "var(--success)";

    setTimeout(() => {
      btnCopyAddress.textContent = originalText;
      btnCopyAddress.style.background = "";
    }, 2000);
  } catch (e) {
    // é™çº§æ–¹æ¡ˆï¼šé€‰æ‹©æ–‡æœ¬
    btcAddressInput.select();
    btcAddressInput.setSelectionRange(0, 99999);
    try {
      document.execCommand('copy');
      const originalText = btnCopyAddress.textContent;
      btnCopyAddress.textContent = "âœ“ å·²å¤åˆ¶";
      setTimeout(() => {
        btnCopyAddress.textContent = originalText;
      }, 2000);
    } catch (err) {
      alert("å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©å¤åˆ¶");
    }
  }
});

// ========== ä¸»é¢˜åˆ‡æ¢åŠŸèƒ½ ==========
const htmlElement = document.documentElement;
const themeToggle = document.getElementById('theme-toggle');
const sunIcon = document.getElementById('sun-icon');
const moonIcon = document.getElementById('moon-icon');

// éšç§æ¨¡å¼ï¼šä¸ä½¿ç”¨ localStorageï¼ˆæ›´å®‰å…¨ï¼Œä¸ç•™ç—•è¿¹ï¼‰
const PRIVACY_MODE = true; // è®¾ç½®ä¸º true ç¦ç”¨ localStorage
let currentThemeState = null; // ä»…åœ¨å†…å­˜ä¸­ä¿å­˜ä¸»é¢˜çŠ¶æ€

function getInitialTheme() {
  if (PRIVACY_MODE) {
    // éšç§æ¨¡å¼ï¼šä»…æ ¹æ®ç³»ç»Ÿåå¥½
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      return 'dark';
    }
    return 'light';
  } else {
    const saved = localStorage.getItem('theme');
    if (saved) return saved;
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      return 'dark';
    }
    return 'light';
  }
}

function setTheme(theme) {
  currentThemeState = theme;
  if (theme === 'dark') {
    htmlElement.setAttribute('data-theme', 'dark');
    sunIcon.style.display = 'block';
    moonIcon.style.display = 'none';
    if (!PRIVACY_MODE) {
      try {
        localStorage.setItem('theme', 'dark');
      } catch (e) {
        console.warn('æ— æ³•ä¿å­˜ä¸»é¢˜åå¥½ï¼ˆéšç§æ¨¡å¼ï¼‰');
      }
    }
  } else {
    htmlElement.removeAttribute('data-theme');
    sunIcon.style.display = 'none';
    moonIcon.style.display = 'block';
    if (!PRIVACY_MODE) {
      try {
        localStorage.setItem('theme', 'light');
      } catch (e) {
        console.warn('æ— æ³•ä¿å­˜ä¸»é¢˜åå¥½ï¼ˆéšç§æ¨¡å¼ï¼‰');
      }
    }
  }
}

// åˆå§‹åŒ–ä¸»é¢˜
setTheme(getInitialTheme());

// ä¸»é¢˜åˆ‡æ¢æŒ‰é’®ç‚¹å‡»äº‹ä»¶
themeToggle.addEventListener('click', () => {
  const currentTheme = htmlElement.getAttribute('data-theme');
  setTheme(currentTheme === 'dark' ? 'light' : 'dark');
});

// ç›‘å¬ç³»ç»Ÿä¸»é¢˜å˜åŒ–ï¼ˆä»…åœ¨ééšç§æ¨¡å¼ä¸”æœªæ‰‹åŠ¨è®¾ç½®æ—¶ï¼‰
if (window.matchMedia) {
  window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
    if (PRIVACY_MODE || (!PRIVACY_MODE && !localStorage.getItem('theme'))) {
      setTheme(e.matches ? 'dark' : 'light');
    }
  });
}

// é¡µé¢åŠ è½½å®ŒæˆåŠ¨ç”»
document.addEventListener('DOMContentLoaded', () => {
  document.body.classList.add('loaded');
});

// é¡µé¢å…³é—­å‰è­¦å‘Šï¼ˆå¦‚æœæœ‰åŠ©è®°è¯æ˜¾ç¤ºï¼‰
window.addEventListener('beforeunload', (e) => {
  const hasMnemonic = mnemonicDiv.textContent.trim().length > 0;
  if (hasMnemonic) {
    e.preventDefault();
    e.returnValue = 'è¯·ç¡®ä¿å·²ä¿å­˜åŠ©è®°è¯ï¼å…³é—­é¡µé¢åå°†æ— æ³•æ¢å¤ã€‚';
    return e.returnValue;
  }
});

// ========== åŠ å¯†ç®—æ³•è‡ªæ£€æµ‹è¯• ==========
async function runCryptoTests() {
  console.log('ğŸ” å¼€å§‹åŠ å¯†ç®—æ³•è‡ªæ£€...');

  try {
    // æµ‹è¯• SHA-256
    const testData = new TextEncoder().encode('hello');
    const sha256Result = await sha256Bytes(testData);
    console.log('âœ“ SHA-256 æµ‹è¯•é€šè¿‡:', bytesToHex(sha256Result).substring(0, 16) + '...');

    // æµ‹è¯• SHA-512
    const sha512Result = sha512Fallback(testData);
    console.log('âœ“ SHA-512 æµ‹è¯•é€šè¿‡:', bytesToHex(sha512Result).substring(0, 16) + '...');

    // æµ‹è¯• RIPEMD160
    const ripemd160Result = ripemd160(testData);
    console.log('âœ“ RIPEMD160 æµ‹è¯•é€šè¿‡:', bytesToHex(ripemd160Result).substring(0, 16) + '...');

    // æµ‹è¯•åŠ©è®°è¯ç”Ÿæˆ
    const entropy = generateEntropy(16);
    const mnemonic = await entropyToMnemonic(entropy, EMBEDDED_BIP39_WORDLIST);
    console.log('âœ“ BIP39 åŠ©è®°è¯ç”Ÿæˆæµ‹è¯•é€šè¿‡');

    // æµ‹è¯•ç§å­ç”Ÿæˆ
    const seed = await mnemonicToSeed('abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about', '');
    console.log('âœ“ ç§å­ç”Ÿæˆæµ‹è¯•é€šè¿‡');

    // æµ‹è¯• secp256k1 å…¬é’¥ç”Ÿæˆ
    try {
      const testPrivKey = new Uint8Array(32);
      testPrivKey[31] = 1; // ç§é’¥ = 1
      const pubKey = privateKeyToCompressedPublicKey(testPrivKey);
      console.log('âœ“ secp256k1 å…¬é’¥ç”Ÿæˆæµ‹è¯•é€šè¿‡:', bytesToHex(pubKey).substring(0, 16) + '...');
    } catch (e) {
      console.warn('âš  secp256k1 æµ‹è¯•è·³è¿‡ (è®¡ç®—å¯†é›†)');
    }

    // æµ‹è¯• Bech32 ç¼–ç 
    const testWitnessProgram = new Array(20).fill(0);
    const bech32Result = encodeBech32Address('bc', 0, testWitnessProgram);
    console.log('âœ“ Bech32 ç¼–ç æµ‹è¯•é€šè¿‡:', bech32Result);

    console.log('âœ… æ‰€æœ‰åŠ å¯†ç®—æ³•è‡ªæ£€é€šè¿‡ï¼');
  } catch (error) {
    console.error('âŒ åŠ å¯†ç®—æ³•è‡ªæ£€å¤±è´¥:', error);
  }
}

// é¡µé¢åŠ è½½åè¿è¡Œè‡ªæ£€
runCryptoTests();

console.log('ğŸ”’ å®Œæ•´ä¿®å¤ç‰ˆå·²åŠ è½½å®Œæˆï¼Œæ‰€æœ‰åŠ å¯†ç®—æ³•å·²å®ç°å¹¶é€šè¿‡è‡ªæ£€');
</script>

</body>
</html>
